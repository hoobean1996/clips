package main

import (
	"bufio"
	"context"
	"flag"
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"

	"com.gigaboo/clipserver/ent"
	"com.gigaboo/clipserver/ent/migrate"
	"entgo.io/ent/dialect"
	_ "github.com/mattn/go-sqlite3"
)

// 字幕条目结构
type SubtitleEntry struct {
	StartTime string
	EndTime   string
	Text      string
}

// 单词片段结构
type WordClip struct {
	Word      string
	StartTime string
	EndTime   string
	Filename  string
}

var videoPath = flag.String("path", "", "视频文件夹路径")

func main() {
	flag.Parse()

	if *videoPath == "" {
		log.Fatal("请使用 -path 参数指定视频文件夹路径")
	}

	// Create ent.Client and run the schema migration.
	client, err := ent.Open(dialect.SQLite, "file:ent?mode=memory&cache=shared&_fk=1")
	if err != nil {
		log.Fatal("opening ent client", err)
	}
	defer client.Close()

	if err := client.Schema.Create(
		context.Background(),
		migrate.WithGlobalUniqueID(true),
	); err != nil {
		log.Fatal("creating schema", err)
	}

	batchProcessVideos(client, *videoPath)
}

func batchProcessVideos(client *ent.Client, path string) {
	log.Printf("开始处理目录: %s", path)

	// 1. 扫描指定目录的所有mp4视频
	videoFiles, err := scanVideoFiles(path)
	if err != nil {
		log.Printf("扫描视频文件失败: %v", err)
		return
	}

	log.Printf("找到 %d 个视频文件", len(videoFiles))

	for _, videoFile := range videoFiles {
		log.Printf("处理视频: %s", videoFile)

		// 2. 检查并获取字幕文件
		subtitleFile := getSubtitleFile(videoFile)

		// 3. 处理字幕文件获取单词列表
		wordClips := processSubtitleFile(videoFile, subtitleFile)

		// 4. 生成视频剪辑并保存到数据库
		for _, wordClip := range wordClips {
			err := generateClipAndSave(client, videoFile, wordClip)
			if err != nil {
				log.Printf("处理单词剪辑失败 %s: %v", wordClip.Word, err)
				continue
			}
			log.Printf("成功创建剪辑: %s", wordClip.Filename)
		}
	}

	log.Println("批处理完成")
}

// 扫描目录中的所有mp4文件
func scanVideoFiles(dir string) ([]string, error) {
	var videoFiles []string

	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if !info.IsDir() && strings.ToLower(filepath.Ext(path)) == ".mp4" {
			videoFiles = append(videoFiles, path)
		}

		return nil
	})

	return videoFiles, err
}

// 获取或生成字幕文件
func getSubtitleFile(videoFile string) string {
	baseDir := filepath.Dir(videoFile)
	baseName := strings.TrimSuffix(filepath.Base(videoFile), filepath.Ext(videoFile))

	// 检查是否已有提取的字幕文件
	preparedSrt := filepath.Join(baseDir, baseName+"_prepared.srt")
	if _, err := os.Stat(preparedSrt); err == nil {
		log.Printf("使用已存在的字幕文件: %s", preparedSrt)
		return preparedSrt
	}

	// 尝试使用ffmpeg提取内置字幕
	if extractEmbeddedSubtitle(videoFile, preparedSrt) {
		log.Printf("成功提取内置字幕: %s", preparedSrt)
		return preparedSrt
	}

	// 使用whisper生成字幕
	if generateSubtitleWithWhisper(videoFile, preparedSrt) {
		log.Printf("成功生成whisper字幕: %s", preparedSrt)
		return preparedSrt
	}

	log.Printf("字幕文件获取失败: %s", videoFile)
	return ""
}

// 使用ffmpeg提取内置字幕
func extractEmbeddedSubtitle(videoFile, outputSrt string) bool {
	cmd := exec.Command("ffmpeg", "-i", videoFile, "-map", "0:s:0", "-c:s", "srt", outputSrt, "-y")
	err := cmd.Run()
	if err != nil {
		log.Printf("ffmpeg提取字幕失败: %v", err)
		return false
	}
	return true
}

// 使用whisper生成字幕
func generateSubtitleWithWhisper(videoFile, outputSrt string) bool {
	cmd := exec.Command("whisper", videoFile, "--output_format", "srt", "--output_dir", filepath.Dir(outputSrt))
	err := cmd.Run()
	if err != nil {
		log.Printf("whisper生成字幕失败: %v", err)
		return false
	}

	// whisper生成的文件需要重命名
	baseName := strings.TrimSuffix(filepath.Base(videoFile), filepath.Ext(videoFile))
	whisperOutput := filepath.Join(filepath.Dir(outputSrt), baseName+".srt")

	if _, err := os.Stat(whisperOutput); err == nil {
		return os.Rename(whisperOutput, outputSrt) == nil
	}

	return false
}

// 处理字幕文件获取单词片段
func processSubtitleFile(videoFile, subtitleFile string) []WordClip {
	if subtitleFile == "" {
		return nil
	}

	// 解析字幕文件
	subtitles := parseSubtitleFile(subtitleFile)
	if len(subtitles) == 0 {
		log.Printf("字幕文件解析失败: %s", subtitleFile)
		return nil
	}

	// 提取所有单词
	words := extractWordsFromSubtitles(subtitles)

	// 为每个单词查找时间戳
	var wordClips []WordClip
	baseDir := filepath.Dir(videoFile)
	baseName := strings.TrimSuffix(filepath.Base(videoFile), filepath.Ext(videoFile))

	for _, word := range words {
		startTime, endTime := findWordTimestamp(word, subtitles)
		if startTime != "" && endTime != "" {
			filename := fmt.Sprintf("%s_%s_%s_%s.mp4", baseName, word,
				strings.ReplaceAll(startTime, ":", "-"),
				strings.ReplaceAll(endTime, ":", "-"))

			wordClips = append(wordClips, WordClip{
				Word:      word,
				StartTime: startTime,
				EndTime:   endTime,
				Filename:  filepath.Join(baseDir, filename),
			})
		}
	}

	return wordClips
}

// 解析SRT字幕文件
func parseSubtitleFile(filename string) []SubtitleEntry {
	file, err := os.Open(filename)
	if err != nil {
		log.Printf("打开字幕文件失败: %v", err)
		return nil
	}
	defer file.Close()

	var subtitles []SubtitleEntry
	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())

		// 跳过序号行和空行
		if line == "" || regexp.MustCompile(`^\d+$`).MatchString(line) {
			continue
		}

		// 时间戳行
		if strings.Contains(line, "-->") {
			parts := strings.Split(line, " --> ")
			if len(parts) == 2 {
				startTime := strings.TrimSpace(parts[0])
				endTime := strings.TrimSpace(parts[1])

				// 读取文本内容
				var textLines []string
				for scanner.Scan() {
					textLine := strings.TrimSpace(scanner.Text())
					if textLine == "" {
						break
					}
					textLines = append(textLines, textLine)
				}

				if len(textLines) > 0 {
					subtitles = append(subtitles, SubtitleEntry{
						StartTime: startTime,
						EndTime:   endTime,
						Text:      strings.Join(textLines, " "),
					})
				}
			}
		}
	}

	return subtitles
}

// 从字幕中提取所有单词
func extractWordsFromSubtitles(subtitles []SubtitleEntry) []string {
	wordSet := make(map[string]bool)

	// 匹配单词的正则表达式
	wordRegex := regexp.MustCompile(`\b[a-zA-Z]+\b`)

	for _, subtitle := range subtitles {
		words := wordRegex.FindAllString(subtitle.Text, -1)
		for _, word := range words {
			word = strings.ToLower(word)
			if len(word) > 2 { // 只保留长度大于2的单词
				wordSet[word] = true
			}
		}
	}

	// 转换为切片
	var words []string
	for word := range wordSet {
		words = append(words, word)
	}

	return words
}

// 查找单词在字幕中的时间戳
func findWordTimestamp(word string, subtitles []SubtitleEntry) (string, string) {
	wordRegex := regexp.MustCompile(`\b` + regexp.QuoteMeta(strings.ToLower(word)) + `\b`)

	for _, subtitle := range subtitles {
		if wordRegex.MatchString(strings.ToLower(subtitle.Text)) {
			return subtitle.StartTime, subtitle.EndTime
		}
	}

	return "", ""
}

// 生成视频剪辑并保存到数据库
func generateClipAndSave(client *ent.Client, videoFile string, wordClip WordClip) error {
	// 使用ffmpeg生成剪辑
	cmd := exec.Command("ffmpeg",
		"-i", videoFile,
		"-ss", wordClip.StartTime,
		"-to", wordClip.EndTime,
		"-c", "copy",
		wordClip.Filename,
		"-y")

	err := cmd.Run()
	if err != nil {
		return fmt.Errorf("ffmpeg剪辑失败: %v", err)
	}

	// 获取文件信息
	fileInfo, err := os.Stat(wordClip.Filename)
	if err != nil {
		return fmt.Errorf("获取文件信息失败: %v", err)
	}

	// 计算duration
	startSeconds := timeToSeconds(wordClip.StartTime)
	endSeconds := timeToSeconds(wordClip.EndTime)
	duration := int64(endSeconds) - int64(startSeconds)

	_, err = client.EntClipMetadata.Create().
		SetFileURL(wordClip.Filename).
		SetFilename(filepath.Base(wordClip.Filename)).
		SetFileSize(int64(fileInfo.Size())).
		SetDuration(int(duration)).
		SetFormat("mp4").
		Save(context.Background())

	if err != nil {
		return fmt.Errorf("保存到数据库失败: %v", err)
	}

	return nil
}

// 将时间字符串转换为秒数
func timeToSeconds(timeStr string) float64 {
	// 格式: 00:00:10,500 或 00:00:10.500
	timeStr = strings.ReplaceAll(timeStr, ",", ".")
	parts := strings.Split(timeStr, ":")

	if len(parts) != 3 {
		return 0
	}

	hours, _ := strconv.ParseFloat(parts[0], 64)
	minutes, _ := strconv.ParseFloat(parts[1], 64)
	seconds, _ := strconv.ParseFloat(parts[2], 64)

	return hours*3600 + minutes*60 + seconds
}
